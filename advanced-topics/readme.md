# Темы сегодняшнего урока: 
* Event loop
* Strict mode
* Iterators and Generators
* Modules in JavaScript
* Memory management 
* All dev tools 

# Event loop

На самом деле тут ничего сложного нет.
Эта тема входит в `Advanced Js` только по 
той причине, что она является одной из самых
сложных для понимания в JavaScript проблем.

Все дело в том, что JavaScript - это однопоточный
язык. Это значит, что в один момент времени он может
выполнять только одну задачу. Но в то же время,
JavaScript - это язык `событийно-ориентированного
программирования` (event-driven programming language).

Это значит, что если у вас несколько задач, которые
нужно выполнить, то они будут выполняться по очереди.

Так в чем же проблема? Проблема в том, что если
выполнение одной из задач занимает много времени,
то все остальные задачи будут ждать, пока она не
закончится. И это может привести к тому, что
пользователь будет долго ждать, пока что-то
произойдет.

Для того, чтобы решить эту проблему, в JavaScript
есть `Event loop`. Он следит за тем, чтобы задачи
выполнялись по очереди, и если какая-то задача
занимает много времени, то он переключается на
другую задачу, а потом возвращается к первой.

Вот пример кода, который демонстрирует это поведение:

```js

console.log('Start');

setTimeout(() => {
    console.log('Timeout');
}, 0);

Promise.resolve().then(() => console.log('Promise'));

console.log('End');

```

Вывод, который получается на экране, будет таким:

```
Start
End
Promise
Timeout
```

То есть это совсем не то что мы ожидали. 

Все дело в том, что `setTimeout` и `Promise` - это
асинхронные операции. Они не выполняются сразу же,
как только их вызвали. Вместо этого они добавляются
в очередь задач, которые будут выполнены позже.

Как решить эту проблему? Для этого есть несколько
способов. Например, можно использовать `async/await`:

```js

console.log('Start');

(async () => {
    await new Promise(resolve => setTimeout(resolve, 0));
    console.log('Timeout');
})();

Promise.resolve().then(() => console.log('Promise'));

console.log('End');

```

## Strict mode

Как вы можете понять из перевода, это строгий режим.
`Strict mode` - это режим, в котором JavaScript
выполняется в более строгом режиме. Это значит,
что некоторые ошибки, которые раньше не вызывали
ошибок, теперь будут вызывать.

Например, если вы попытаетесь присвоить значение
переменной, которая не была объявлена, то в обычном
режиме это не вызовет ошибку, а в строгом режиме
вызовет.

Для того, чтобы включить строгий режим, нужно
добавить строку `'use strict';` в начало файла.

## Iterators and Generators

Мы уже проходили итераторы и генераторы, но я хочу вам напомнить о них.

Итератор - это объект, который позволяет перебирать элементы коллекции.
Генератор - это функция, которая может возвращать несколько значений.

чтобы сделать функцию генератором, нужно поставить перед ее именем звездочку:

```js
function* generator() {
    yield 1;
    yield 2;
    yield 3;
}
```

В чем разница между итератором и генератором? Итератор - это объект, который
можно использовать для перебора элементов коллекции. Генератор - это функция,
которая может возвращать несколько значений.

То есть итератор выглядит так:

```js

const iterator = {
    value: 1,
    done: false,
    next() {
        return {
          this: this.value++,
          done: true  
        }
    }
}

iterator.next(); // { value: 1, done: false }
```

Генератор выглядит так:

```js

class A {
    constructor() {
        this.value = 1;
    }

    *generator() {
        yield this.value++;
    }
}

const a = new A();

console.log(a.generator().next().value)
console.log(a.generator().next().value)
console.log(a.generator().next().value)
console.log(a.generator().next().value)

```

## Modules in JavaScript

Модули - это способ организации кода. Вместо того, чтобы писать весь код в одном
файле, его можно разбить на несколько файлов. Это позволяет лучше организовать
код, а также переиспользовать его.

В JavaScript есть несколько способов организации кода. Например, можно использовать

* CommonJS
* ES6 Modules
* SystemJS

### CommonJS

Это стандарт модулей, который используется в Node.js. Он позволяет импортировать
и экспортировать модули. Например, вот так можно экспортировать модуль:

```js

module.exports = {
    a: 1,
    b: 2,
    c: 3
}

```

А вот так можно импортировать модуль:

```js

const module = require('./module');

console.log(module.a); // 1

```

## ES6 Modules

Это стандарт модулей, который используется в браузерах. Он позволяет импортировать
и экспортировать модули. Например, вот так можно экспортировать модуль:

```js

export function a() {
    return 1;
}

export const b = 2;

class A {
    constructor() {
        this.c = 3;
    }
}

export default A;

```

А вот так можно импортировать модуль:

```js

import A, { a, b } from './module';

```

## SystemJS 

Это стандарт модулей, который используется в браузерах. Он позволяет импортировать
и экспортировать модули. Например, вот так можно экспортировать модуль:

```js

System.register('module', [], function() {
    return {
        setters: [],
        execute: function() {
            return {
                a: 1,
                b: 2,
                c: 3
            }
        }
    }
});

```

А вот так можно импортировать модуль:

```js

System.import('module').then(module => {
    console.log(module.a); // 1
});

```

И тут исходит важный вопрос - где используется SystemJS ? 
Ответ простой - нигде.

Это уже устаревший стандарт, который больше не используется.

## Memory management

Мы уже знаем, что все запускается в браузере и это не дает нам такого полного контроля 
памятью как в C++.

В JS управление памятью автоматическое как наример в C#, кстати очень интересно, что
они очень похожи.

В общем `JS` работает с искуственной памятью, которая уже была выеделена нашему браузеру. 
То есть вы не можете взять и выделить память под свой объект, как в C++.

Из чего состоит память в JS:
* Stack
* Heap


### Stack

В стеке хранятся примитивные типы данных, такие как `number`, `string`, `boolean`, `null`, `undefined`, `symbol`.

### Heap

В куче хранятся все объекты, которые мы создаем. Например, объекты, массивы, функции и т.д.

То есть по сути это тоже самое как и в C#, просто там мы называли это 
`value types` и `reference types`.


### Garbage collector

Все что находится в стеке, удаляется автоматически, как только функция заканчивает свое выполнение.

Но что делать с кучей? Как мы можем удалять объекты, которые мы создали?

Для этого есть `Garbage collector`. Он следит за тем, чтобы объекты, которые больше не используются,
были удалены из памяти. Например, если у вас есть объект, который больше не используется, то он будет удален.

![](https://i.imgur.com/kSgatSL.png)

![Важная статья](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_management)


## All dev tools

Про это я говорил еще на первом уроке. Дело в том, что в браузере есть много полезных инструментов,
но иногда не совсем удоюно им пользоваться. Для этого есть специальные расширения для браузеров,
которые позволяют удобно пользоваться этими инструментами.

Например: 
* [React Developer Tools](https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi)
* [Redux DevTools](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd)
* [Vue.js devtools](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd)

Но как вы можете понять из названия, они работают только с определенными фреймворками.

Из-за этого я вам советую использовать `Debugger` в вашем IDE, но чтобы оно работало, 
нужно установить `Node.js` и `npm` на ваш компьютер.

После этого вы можете запустить ваш проект в режиме `debug` и поставить `breakpoint` в нужном месте.

Сам `DevTools` браузера я вам уже показывал.


