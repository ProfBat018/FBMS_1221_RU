# Тема урока. ThreadPool, CountDownEvent

## ThreadPool - это набор готовых потоков, создзанных CLR для нашего использования.

# Что мы должны знать о ThreadPool:
* Количество созданных потоков по умолчанию зависит от типа вашего приложения, CLR, мощности процессора и т.д.
* Если кол-во потоков будет недостаточно, то CLR создаст еще потоки.
* Если кол-во потоков будет избыточным, то CLR уберет лишние потоки.
* ***Потоки из ThreadPool - это фоновые потоки.***
* Если ваш процесс закончится очень быстро, то он может оставить вам старый поток для продолжения следующей работы.


# class ThreadPool в C#
* Методы
* 1. QueueUserWorkItem - добавляет метод в очередь на выполнение
* 2. GetAvailableThreads - получает кол-во доступных потоков
* 3. GetMaxThreads - получает максимальное кол-во потоков
* 4. GetMinThreads - получает минимальное кол-во потоков
* 5. SetMaxThreads - устанавливает максимальное кол-во потоков
* 6. SetMinThreads - устанавливает минимальное кол-во потоков

### QueueUserWorkItem

У этой функции есть 2 перегрузки:
* 1. QueueUserWorkItem(WaitCallback callBack) - добавляет метод в очередь на выполнение
* 2. QueueUserWorkItem(WaitCallback callBack, object state) - добавляет метод в очередь на выполнение и передает ему параметр state. Параметр state нужен для передачи данных в метод, который будет выполняться в отдельном потоке.


## ManualResetEvent и AutoResetEvent

Оба этих класса наследуются от класса WaitHandle. Это означает, что они могут использоваться в качестве параметра для метода QueueUserWorkItem. Эти классы нужны для синхронизации потоков. Они позволяют потоку ожидать сигнала от другого потока.

### ManualResetEvent

* 1. ManualResetEvent(bool initialState) - создает объект ManualResetEvent. Параметр initialState определяет, будет ли объект в сигнальном состоянии.

* 2. Set() - устанавливает объект в сигнальное состояние.

* 3. Reset() - устанавливает объект в несигнальное состояние.

* 4. WaitOne() - ожидает сигнала от другого потока. Если сигнал получен, то метод возвращает true, иначе false.

### AutoResetEvent

* 1. AutoResetEvent(bool initialState) - создает объект AutoResetEvent. Параметр initialState определяет, будет ли объект в сигнальном состоянии.

* 2. Set() - устанавливает объект в сигнальное состояние.

* 3. Reset() - устанавливает объект в несигнальное состояние.

* 4. WaitOne() - ожидает сигнала от другого потока. Если сигнал получен, то метод возвращает true, иначе false.


Разница между ManualResetEvent и AutoResetEvent в том, что ManualResetEvent остается в сигнальном состоянии до тех пор, пока не будет вызван метод Reset(). А AutoResetEvent возвращается в несигнальное состояние сразу после того, как один поток получит сигнал.


## CountDownEvent

Этот класс нужен для синхронизации потоков. Он позволяет одному потоку ожидать завершения других потоков.

* 1. CountDownEvent(int initialCount) - создает объект CountDownEvent. Параметр initialCount определяет кол-во потоков, которые должны завершиться, чтобы основной поток продолжил свою работу.

* 2. AddCount(int signalCount) - увеличивает кол-во потоков, которые должны завершиться, чтобы основной поток продолжил свою работу.

* 3. Signal() - уменьшает кол-во потоков, которые должны завершиться, чтобы основной поток продолжил свою работу.

* 4. Wait() - ожидает завершения всех потоков. Если все потоки завершились, то метод возвращает true, иначе false.

* 5. Dispose() - освобождает ресурсы, занятые объектом CountDownEvent.

Тут хочу отметить что этот гагаш IDisposeble, поэтому его нужно закрывать.


В случае с Manual или Auto reset event, мы даем сигнал методом Set, но в CountDown event мы ждем пока он не дойдет до нуля... и только потом продолжаем работу основного потока.