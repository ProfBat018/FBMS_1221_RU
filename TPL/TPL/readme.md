# Темы урока: 
* Память Thread 
* TPL
* Task
* ASYNC/AWAIT
* Interlocked
* Volatile


## Память Thread
Мы уже знаем, что каждый процесс
состоит из одного или нескольких
потоков. Каждый поток имеет свою
собственную память, но также у 
них есть общая память. Вот схема: 

![img.png](https://tooslowexception.com/wp-content/uploads/2019/08/gcposter05.png)

Все потоки имеют доступ к общей памяти,
но каждый поток имеет свою собственную
память. Поэтому, если один поток изменяет
значение переменной, то другой поток
может не увидеть этих изменений.


Поговорим о Dispatcher. На прошлом уроке мы поняли
что Dispatcher - это объект, который позволяет нашему потоку
делить свою память с другими потоками. 

Есть два типа Dispatcher:
* DispatcherSynchronizationContext
* DispatcherObject

`DispatcherSynchronizationContext` - это объект, который
позволяет потоку делить свою память с другими потоками.

`DispatcherObject` - это объект, который позволяет потоку
делить свою память с другими потоками, но также он
позволяет потоку делить свою память с другими потоками
и синхронизировать их.

Когда мы используем Dispatcher, то мы используем DispatcherSynchronizationContext.

Принцип работы `Dispatcher` - это очередь. Когда мы добавляем
в очередь задачу, то она выполняется в том потоке, который
её добавил. И другие потоки не могут её выполнить. При этом они его видят.

[Dispatcher](https://learn.microsoft.com/ru-ru/dotnet/api/system.windows.threading.dispatcher?view=windowsdesktop-7.0)


## TPL

`TPL` - это библиотека, которая позволяет нам работать с потоками параллельно.
Еще раз говорю, все это псевдо-параллельность. На самом деле, это просто очередь.

Основная задача `TPL` - это упростить работу с потоками. 
По факту он состоит из:
* Task
* async/await
* Parallel
* PLINQ

### Task
Task работает через ThreadPool. Это значит, что он не создает новые потоки,
а использует уже существующие. Поэтому, если мы создадим 1000 задач, то они
будут выполняться в 1000 потоков, а в 1000 потоков не влезет.
Task имеет свои собственные методы ожидания, которые позволяют нам
ждать выполнения задачи, например `Task.Wait()`.

Task.Wait() - это синхронный метод, который ожидает выполнения задачи.
Task.WaitAll() - это синхронный метод, который ожидает выполнения всех задач.
Task.GetAwaiter().GetResult() - это синхронный метод, который ожидает выполнения задачи.


Подроюнее про Awaiter. Awaiter - это объект, который позволяет нам
ждать выполнения задачи. Вот пример:

То есть при завершении задачи он возвращает событие, которое говорит о том что 
event с результатом выполнения задачи. 


## Interlocked
Interlocked - это класс, который позволяет нам работать с переменными
безопасно. Например, если мы хотим увеличить переменную на 1, то мы можем
использовать метод `Interlocked.Increment(ref int)`. Этот метод гарантирует
нам, что переменная будет увеличена на 1.


## [Volatile](https://learn.microsoft.com/ru-ru/dotnet/csharp/language-reference/keywords/volatile)
Ключевое слово volatile означает, что поле может изменить несколько потоков, выполняемых одновременно. Компилятор, среда выполнения или даже аппаратное обеспечение могут изменять порядок операций чтения и записи в расположения в памяти для повышения производительности. Поля, которые объявлены volatile, исключаются из некоторых типов оптимизации. Нет никакой гарантии единого общего порядка временных записей во всех потоках выполнения


