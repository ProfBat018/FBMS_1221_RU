# Тема урока. Efficient querying in Ef Core

## Цель урока
* Познакомиться с основными принципами построения запросов в Entity Framework Core
* Познакомиться с основными методами расширения для построения запросов
* Понять как строить эффективные запросы
* `LINQ to Entities` vs `LINQ to Objects` vs `LINQ to SQL`
* Посмотреть на рекомендации по написанию запросов на `MSDN`

<br>
<br>

# ***ЗАПОМНИТЕ РАЗ И НАВСЕГДА***
## Вся выборка, которая может производиться на стороне БД, должна производиться на стороне БД

<br>

# Основные принципы построения запросов в Entity Framework Core

Какие основные принципы построения запросов в Entity Framework Core вы знаете ?

Всего есть 3 основных способа построения запросов в Entity Framework Core:
* `LINQ to Entities`
* `LINQ to Objects`
* `LINQ to SQL`

<br>


## `LINQ to Entities` - это LINQ методы, вызванные у DbSet<T>, то есть методы, которые будут преобразованы в SQL запрос и отправлены в БД

<br>


## `LINQ to Objects` - это LINQ методы, вызванные у любых объектов в `C#`, то есть методы, которые не имеют отношения к Entity Framework Core и будут выполнены на стороне `C#`

<br>

## `LINQ to SQL` - это LINQ методы, вызванные у объектов типа `IQueryable<T>`, то есть методы, которые будут преобразованы в SQL запрос и отправлены в БД. В чем разница ? В синтаксисе.

<br>

### Например, `LINQ to SQL` позволяет использовать `SQL` операторы, такие как `GROUP BY`, `HAVING`, `UNION`, `INTERSECT`, `EXCEPT` и т.д.

Примеры запросов на `LINQ to Entities`:
```csharp
var query = context.Users.Where(u => u.Name == "John"); // User
// sql query: SELECT * FROM Users WHERE Name = 'John'
```

Примеры запросов на `LINQ to Objects`:
```csharp
var query = context.Users.ToList().Where(u => u.Name == "John");
// sql query: SELECT * FROM Users

List<User> query2 = context.Users.Tolist();
User userRes = query2.Where(u => u.Name == "John").FirstOrDefaul();
```

Примеры запросов на `LINQ to SQL`:
```csharp
var query = from u in context.Users
            where u.Name == "John"
            select u;
// sql query: SELECT * FROM Users WHERE Name = 'John'
```

Ответы на вопросы:
* В чем разница между Iqueryable и IEnumerable ?

`IQueryable` - это интерфейс, который возвращает сырой результат запроса, то есть вы видите данные, которые вернула БД, но при это вы не взяли их.
`IEnumerable` - это интерфейс, который хранит в себе только результат запроса.


# Чтобы строить эффективные SQL запросы необходимо знать:
* Use indexes properly/ Используйте индексы правильно
* Project only properties you need/ Проектируйте только те свойства, которые вам нужны
* Limit the result set/ Ограничьте количество возвращаемых записей
* Use paging/ Используйте постраничную выборку
* Avoid cartesian products/ Избегайте декартовых произведений
* Load related data in a single round trip/ Загружайте связанные данные за один запрос
* Load related data eagerly if it possible/ Загружайте связанные данные заранее, если это возможно
* Beware of lazy loading/ Остерегайтесь ленивой загрузки
* Buffering and Streaming/ Буферизация и потоковая передача
* AsNoTracking 
<br>

# Use indexes properly/ Используйте индексы правильно

Если у вас есть индекс, то поиск по нему будет происходить быстрее, чем поиск по неиндексированному полю. Но индексировать все поля не стоит, так как это может привести к ухудшению производительности при вставке и обновлении данных. Индексировать стоит только те поля, по которым вы часто ищете данные.

<br>

# Project only properties you need/ Проектируйте только те свойства, которые вам нужны

```csharp
var query = context.Users.Select(u => new { u.Name, u.Age });
```

<br>

# Limit the result set/ Ограничьте количество возвращаемых записей

```csharp
var query = context.Users.Take(10);
var query = context.Users.Where(u => u.Age > 18).FirstOrDefault();
```

<br>

# Use paging/ Используйте постраничную выборку

Это нужно для того чтобы загружать данные на страницу вашего приложения по частям, а не все сразу. Таким образом вы сможете уменьшить нагрузку на БД и увеличить скорость загрузки страницы.

```csharp
var i = 0;
var query = context.Users.Skip(i).Take(10);
i += 10;

```
По сути вы меняете значение `Skip` при переключении страницы.

<br>

# Avoid cartesian products/ Избегайте декартовых произведений

Декартово произведение - это когда вы делаете `join` без указания условия, то есть вы просто объединяете 2 таблицы. Это приводит к тому, что вы получаете все возможные комбинации записей из 2 таблиц.

Например при соединении двух таблиц, вы получаете такой результат в SQL:

____________________________________________
| id | name | Personid | name | id | Personname | id | name |
|----|------|----------|------|----|------------|----|------|
| 1  | John | 1        | John | 1  | John       | 1  | John |

Пример sql запроса:
```sql  
SELECT * FROM Users u
INNER JOIN Persons p ON u.PersonId = p.Id

SELECT u.Id, u.Name, u.Surname, p.Age FROM Users u, Persons p
WHERE u.PersonId = p.Id
```



<br>

# Load related data in a single round trip/ Загружайте связанные данные за один запрос

Если вы хотите получить данные из связанной таблицы, то не нужно делать отдельный запрос, чтобы получить данные из этой таблицы. Вместо этого можно использовать `Include` или `ThenInclude` для загрузки связанных данных.


<br>

# Load related data eagerly if it possible/ Загружайте связанные данные заранее, если это возможно

Если вы знаете, что вам понадобятся данные из связанной таблицы, то лучше загрузить их заранее, чтобы не делать отдельный запрос. К стати как спойлер советую тут же использовать `AsNoTracking`, чтобы не засорять кэш. 

Делайте это, если уверены, что вам понадобятся данные из связанной таблицы.

<br>

# Beware of lazy loading/ Остерегайтесь ленивой загрузки

Ленивая загрузка - это когда вы получаете данные из связанной таблицы, но при этом не делаете отдельный запрос. Вместо этого вы получаете данные из связанной таблицы, когда обращаетесь к ним. Это может привести к тому, что вы получите большое количество запросов к БД, что приведет к ухудшению производительности.

***Все неявное - это плохо***

<br>

# Buffering and Streaming/ Буферизация и потоковая передача

По умолчанию `EF Core` использует буферизацию, то есть все данные загружаются в память и только потом передаются в приложение. Это может привести к тому, что вы получите большое количество запросов к БД, что приведет к ухудшению производительности.

Чтобы избежать этого можно использовать потоковую передачу, то есть данные будут передаваться в приложение по мере их получения. Это можно сделать с помощью `AsNoTracking` и `AsStreaming`.

<br>

# AsNoTracking

`AsNoTracking` - это метод, который отключает отслеживание изменений. Это нужно для того, чтобы не засорять кэш, если вы не собираетесь обновлять данные.

<br>

# AsStreaming

`AsStreaming` - это метод, который включает потоковую передачу. Это нужно для того, чтобы не загружать все данные в память, а передавать их по мере их получения.






