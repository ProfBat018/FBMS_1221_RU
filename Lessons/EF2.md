# Оптимизационные моменты в EF 

## Оптимизация запросов
Не нужно делать вот так: 
```csharp
    var users = context.Users.ToList();
    foreach(var user in users)
    {
        Console.WriteLine(user.Name);
    }
```

Лучше делать вот так:
```csharp
    var users = context.Users.Select(u => u.Name);
    foreach(var user in users)
    {
        Console.WriteLine(user);
    }
```

Это называется `Projection` - выборка определенных полей из таблицы.

То есть если из всех свойств объекта нам нужно только 1, то мы можем выбрать только его, из-за этого мы используем LINQ to Entities, а не LINQ to Objects.

В данном случае вам нужно понять какой SQL запрос генерируется в первом случае, а какой запрос генерируется во втором.

#### Первый запрос
```sql
SELECT * FROM Users
```

#### Второй запрос
```sql
SELECT Name FROM Users
```

Второй запрос будет работать быстрее, так как он выбирает только 1 поле, а не все поля.


### IQueryable vs IEnumerable vs ToList vs ToArray


#### IQueryable

`IQueryable` - это интерфейс, но в отличии от `List`, `IQueryable` работает с LINQ to Entities, а не с LINQ to Objects.

По сути используя IQueryable мы говорим EF, что мы хотим сделать запрос в базу данных, а не взять все данные из таблицы и потом уже делать запрос, то есть мы не храним эти данные в списке, а просто делаем запрос в базу данных.

### AsNoTracking

Что такое `AsNoTracking`?

`AsNoTracking` - это метод, который говорит EF, что мы не хотим отслеживать изменения объектов, которые мы получаем из базы данных.

По умолчанию EF отслеживает изменения объектов, которые мы получаем из базы данных, чтобы потом сохранить их в базу данных.

`AsNoTracking` увеличивает производительность, так как EF не будет отслеживать изменения объектов, которые мы получаем из базы данных.

По умолчанию EF уже использует транзакции, поэтому если что-то пойдет не так, то EF откатит изменения.



